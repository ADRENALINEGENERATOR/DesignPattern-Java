# 2. 객체지향 프로그래밍, 객체지향 설계

## 추상화

- 어떤 영역에서 필요로 하는 속성이나 기능을 추출하는 작업

- 데이터 구조, 표현방법에 대한 추상화

- 처리 과정에 대한 추상화

추상화란 abstract입니다. 어떤 구체적인 사물들이 있습니다. 사람이다 라고 하면 사람에 대해서 여러가지 특성들이 있고, 회사의 직원이다라고 하면 회사의 직원에 대한 여러가지 특성이 있고, 어쨋든 우리가 어떤 프로그램을 개발 한다고 하면 똑같은 사람이어도 직원일때랑 학교의 학사 관리 시스템 안에 있는 학생일때랑 전혀 다른 속성과 프로퍼티가 필요합니다.

그래서 클래스는 뭐라고 하냐면 객체의 설계도라고 합니다. 왜냐하면 각각의 클래스 안에 그 객체가 해야 되는 기능들을 메서드로 정리를 하기 때문입니다.

그리고 인스턴스화 해서 즉 new 했을 때 어떤 클래스라고 해서 홍길동 학생, 이몽룡 학생 이렇게 학생을 직접 만드는데, 이런 객체들의 속성과 기능을 추상화 해서 만드는것이 객체지향 프로그램에서 중요한 부분입니다.

## 캡슐화

- 데이터를 감싸서 외부에서 사용 가능한 부분만을 제공 (Infomation hiding)

- 사용하는 코드(클라이언트 코드)가 세부적인 사항을 알 필요가 없음

- 단순한 접근을 제공하여 오류가 생길 부분을 감소함 


캡슐화는 클래스나 객체를 만들고 나면 외부에서 접근할 수 있는 방법을 제공해줘야 하는데 그 접근 할 수 있는 방법을 public하게 제공해주는 부분과 그리고 모든 기능과 속성을 다 오픈하지 않게 private라는 키워드를 사용 합니다.

그리고 클라이언트쪽에서 이 코드를 쓸 때 클라이언트가 효율적으로 쓸수있도록 인터페이스를 오픈합니다. 이 말인 즉슨 메서드들을 오픈한다는 뜻입니다.

인터페이스라는 용어도 이제 많이 나오는데 인터페이스라는 용어가 자바에서는 인터페이스라는 키워드를 사용하고 원래 는 소프트웨어공학에서 쓰는 용어입니다.

이 인터페이스는 일종의 통로라고 생각하면 되고, 그래서 소프트웨어 설계에 대해서 나온 책들을 보면 인터페이스라는 용어가 어쩔때는 메서드를 인터페이스라고도 하고, 자바의 인터페이스를 인터페이스라고 부르기도 합니다. 서로 혼용되기도 하는데 결국엔 오픈된 API 라고 부릅니다.

그래서 클라이언트가 사용하기 쉽게 인터페이스를 제공하는데 이건 결국 어떤 목적이 있냐면 내 객체를 보호하는 목적이 있습니다. 그래서 클라이언트한테 모든 메서드를 오픈하게 되면 클라이언트가 잘못 사용할수도 있고, 문제를 일으킬수도 있습니다. 그래서 필요한 로직은 내부적으로 감싸고 어떤 일관적인 인터페이스를 오픈하는 이런게 캡슐화라고 생각하시면 됩니다.

## 상속성

- 일반적인(general) 개념의 객체에서 보다 구체적인(specific) 개념의 객체의 관계를 표현

- 상속관계의 클래스는 상위 클래스의 타입을 내포함

- 상위 클래스의 속성과 기능을 하위 클래스에서 사용하거나 재정의 할 수 있음


상속을 코드의 재사용성이라 생각하면 안됩니다. 그래서 내가 코드를 재사용하기 위해서 상속을 사용할거야! 라는것은 상당히 위험한 생각입니다. 상속을 쓸때는 어떻게 써야하냐면 조금 더 일반적인 개념에서 보다 구체적인 개념의 객체의 관계를 표현할 때 사용합니다. 그래서 이런 상속을 기반으로 다형성이 구현될수 있습니다.

## 다형성 (polymorphism)

- 같은 메세지, 같은 구현에 대해 각 객체가 다른 표현과 결과를 나타내는 것

- 클래스의 상속, 인터페이스의 구현 시에 각각의 다른 구현을 가진 클래스들이 상위 타입으로 업캐스팅이 되고 
  
 이 때, 각 클래스에서 오버라이딩한 메서드가 존재하는 경우 같은 상위 타입으로 선언된다 하더라도 각기 다른 인스턴스의 메서드가 호출되는것

 C++의 경우 virtual fuction만이 재정의된 함수가 호출되지만 자바의 경우는 모든 메서드가 가상함수 기반으로 구현되므로 하위 클래스에 재정의된 메서드가 있는 경우 재정의된 메서드가 호출 됨


다형성이라는 "것은 같은 메세지, 같은 구현에 대해 각 객체가 다른 표현과 결과를 나타내는 것" 결국은 코드는 한줄인데 결과가 다릅니다.

이 뜻이 뭐냐면 자바 공부 하신분들은 아시겠지만 가상 메서드에 의해서 인스턴스의 메서드가 호출되기 떄문입니다.

때문에 클라이언트쪽에서는 하위 클래스를 직접 생성하는것이 아니라 상위 클래스 타입으로 접근을 하게 되면 모든 하위 클래스들을 핸들링 할 수 있게 됩니다.

## 객체 지향 설계

- Design Heuristics

  **Abstract class vs. Concrete Class**

  **Class Inheritance vs. Object Composition**

  **Interface Inheritance vs, Implementation Inheritance Etc...**


### Abstract class vs. Concrete Class
설계적인 측면에서 이렇게 설계하는게 좋은가, 저렇게 설계하는게 좋은가 라는 여러가지 고민들을 하게 됩니다.

그래서 추상 클래스로 만들 것이냐, 구체적인 클래스로 만들것이냐 그래서 추상 클래스를 abstract class라는 용어를 쓰고,

implements 되어있는 즉 new 할 수 있는 클래스는 concrete class라는 용어를 사용합니다.

abstract class로 설계를 한다고 하면 new 할 수 없습니다. abstract class는 명백히 뭘 하기 위해서 만들어진 클래스냐면 자기가 다 구현하지 않은 부분을 상속하는 클래스가 구현하게끔 하기 위해서 만든 클래스입니다.

간 혹 이미 모두 구현이 되있어도 abstract 키워드를 사용하면 abstract class가 됩니다. 즉 new을 할 수가 없습니다.

이런 경우는 왜 만드냐면 abstract 키워드를 사용한 class도 상위 클래스가 될것이고 하위 클래스들이 abstract 키워드를 사용한 class의 기능을 사용할 것이다 라는 의미로 만든것입니다.


### Class Inheritance vs. Object Composition
그리고 재사용을 한다라는 측면에서 보면 Class Inheritance 즉 상속을 사용할 것이냐, Object Composition 합성을 사용할 것이냐인데 기본적으로 재사용을 한다면 그 객체의 합성을 사용하면 안됩니다.

그 객체를 내 맴버변수로 선언 한다던가 그래서 생성자에서 new 한다던가 이렇게 해서 가져다 쓰는거를 합성이라 얘기를 하는데, 예를들어 ArrayList를 보면 내가 어떤 배열에 기반한 구현을 한다고 해서 모두 ArrayList를 상속 받지는 않습니다. ArrayList를 포함해서 내부적으로 배열을 활용할 수가 없기 떄문입니다. 그렇기 때문에 이런 경우를 Composition이라고 합니다.

그래서 위의 글처럼 상속은 언제 쓰냐면 상위 클래스의 개념을 포함한 좀 더 구체적인 하위 클래스를 만들때 상속을 쓰고, 상속을 쓰게 되면 클래스간에 결합도가 상당히 높아집니다.

왜냐하면 상위클래스의 어떤 변수나 메서드를 수정하게 되면 하위 클래스에 영향이 가고, 그다음에 하위 클래스가 상위 클래스의 메서드를 오버라이딩 할 수 있고 변수의 값을 하위 클래스에서 재정의 할 수 있기 때문입니다.

그래서 클래스간의 결합도가 굉장히 타이트한게 상속의 개념입니다. 그래서 상속을 설계를 할 떄는 고민을 많이 해야하고, 이렇게 상속으로 설계된 클래스는 하나의 타입으로 핸들링 할 수가 있습니다.


## 응집도(cohesion)와 결합도(coupling)

- 잘 만들어진 소프트웨어는 응집도는 높고 결합도는 낮아야 함

**응집도**

- 하나의 모듈, 객체 내부의 요소들간의 연관성

- 하나의 책임을 구현하는 하나의 객체는 높은 응집도를 가짐


응집도라는거는 "하나의 클래스 안에 보면 서로간의 연관관계, 코드의 연관관계가 얼마나 타이트한가?" 라는 뜻입니다.

결국에는 응집도는 높을수록 좋다는 뜻입니다. 어떤 기능을 이 클래스에서 제공을 했는데 이 클래스안에 서로 관련이 없는 코드가 여기저기 있다면 이 클래스의 성격이 모호해지는데, 학생이다라고 하면 학생에 대한 부분만 있어야지 예를들어 학생의 프로퍼티를 정의하고, 학생이 해야하는 기능들을 정의 하면 되지, 학생안에서 디비오퍼레이션이 일어나고 그다음에 화면에 보여줄 HTML이 있고 ... 이런게 학생 클래스에서 해야 할 일이 아닙니다.

그래서 이런식으로 어떤 클래스가 너무 많은 기능을 다양하게 제공한다면 이것은 결국에 응집도가 떨어질수밖에 없습니다.

그래서 응집도는 높을 수록 좋습니다. 관련된 기능들이 딱 한군데 모여 있어야 어떤 변경 사항이 필요하더라도 거기만 고치면 됩니다. 


**결합도**

- 객체 상호관의 연관 관계

- 결합도가 높으면 하나의 객체를 수정할 때 다른 객체도 수정해야 함


결합도는 느슨할수록 좋습니다. 상속은 결합도가 타이트 하지만 다른 클래스간에 결합도는 느슨하게 하는게 좋습니다. 그래서 느슨한 결합을 위해서 우리가 abstract class나 interface를 활용하는 경우들이 많이 있습니다.

즉 응집도는 높고, 결합도는 낮게 설계하는것이 좋다 라는것이 객체지향 설계의 기본이라고 보면 됩니다.